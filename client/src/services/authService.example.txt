/**
 * EXEMPLO DE SERVIÇO DE AUTENTICAÇÃO
 *
 * Este é um arquivo de exemplo mostrando como estruturar um serviço
 * para comunicação com o backend.
 *
 * Para usar:
 * 1. Copie este arquivo para authService.ts
 * 2. Atualize a URL de baseURL
 * 3. Ajuste os endpoints conforme seu backend
 * 4. Importe em AuthContext.tsx
 */

// Tipos
export interface User {
  id: string
  name: string
  email: string
  cpf?: string
  phone?: string
  createdAt?: string
}

export interface LoginRequest {
  email: string
  password: string
}

export interface LoginResponse {
  token: string
  user: User
}

export interface RegisterRequest {
  name: string
  email: string
  cpf: string
  phone: string
  password: string
}

export interface RegisterResponse {
  token: string
  user: User
}

// Configuração
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api'

// Cliente HTTP
const apiClient = {
  async fetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${API_BASE_URL}${endpoint}`
    const token = localStorage.getItem('authToken')

    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...options.headers,
    }

    if (token) {
      headers['Authorization'] = `Bearer ${token}`
    }

    const response = await fetch(url, {
      ...options,
      headers,
    })

    if (!response.ok) {
      const error = await response.json().catch(() => ({}))
      throw new Error(error.message || `Erro ${response.status}`)
    }

    return await response.json()
  },
}

// Serviço de Autenticação
export const authService = {
  /**
   * Fazer login com email e senha
   */
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response = await apiClient.fetch<LoginResponse>('/auth/login', {
      method: 'POST',
      body: JSON.stringify(data),
    })

    // Armazenar token automaticamente
    if (response.token) {
      localStorage.setItem('authToken', response.token)
    }

    return response
  },

  /**
   * Registrar novo usuário
   */
  async register(data: RegisterRequest): Promise<RegisterResponse> {
    const response = await apiClient.fetch<RegisterResponse>('/auth/register', {
      method: 'POST',
      body: JSON.stringify(data),
    })

    // Armazenar token automaticamente
    if (response.token) {
      localStorage.setItem('authToken', response.token)
    }

    return response
  },

  /**
   * Validar token atual
   */
  async validateToken(): Promise<User> {
    const token = localStorage.getItem('authToken')

    if (!token) {
      throw new Error('Nenhum token disponível')
    }

    return await apiClient.fetch<User>('/auth/validate', {
      method: 'GET',
    })
  },

  /**
   * Fazer logout
   */
  async logout(): Promise<void> {
    try {
      await apiClient.fetch<void>('/auth/logout', {
        method: 'POST',
      })
    } finally {
      // Sempre remover token localmente, mesmo se logout falhar
      localStorage.removeItem('authToken')
    }
  },

  /**
   * Obter token armazenado
   */
  getToken(): string | null {
    return localStorage.getItem('authToken')
  },

  /**
   * Remover token armazenado
   */
  removeToken(): void {
    localStorage.removeItem('authToken')
  },

  /**
   * Verificar se usuário está autenticado
   */
  isAuthenticated(): boolean {
    return !!this.getToken()
  },
}

// ============================================
// EXEMPLO DE USO NO AuthContext
// ============================================

/*
import { authService } from '@/services/authService'

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  // Validar token ao montar
  useEffect(() => {
    const validateToken = async () => {
      if (!authService.isAuthenticated()) return

      try {
        setIsLoading(true)
        const user = await authService.validateToken()
        setUser(user)
      } catch (err) {
        authService.removeToken()
      } finally {
        setIsLoading(false)
      }
    }

    validateToken()
  }, [])

  const login = useCallback(async (email: string, password: string) => {
    setIsLoading(true)
    try {
      const response = await authService.login({ email, password })
      setUser(response.user)
    } finally {
      setIsLoading(false)
    }
  }, [])

  const register = useCallback(async (...) => {
    setIsLoading(true)
    try {
      const response = await authService.register({...})
      setUser(response.user)
    } finally {
      setIsLoading(false)
    }
  }, [])

  const logout = useCallback(async () => {
    try {
      await authService.logout()
    } finally {
      setUser(null)
    }
  }, [])

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        register,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}
*/
